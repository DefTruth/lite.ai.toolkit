# Some very useful onnxruntime c++ interfaces 

![](https://img.shields.io/github/stars/DefTruth/lite.ai.toolkit.svg?style=social) ![](https://img.shields.io/github/forks/DefTruth/lite.ai.toolkit.svg?style=social) ![](https://img.shields.io/github/watchers/DefTruth/lite.ai.toolkit.svg?style=social)
  
æ•´ç†ä¸æ˜“ï¼Œæ¬¢è¿å…³æ³¨ï¼ŒğŸŒŸç‚¹èµæ”¶è—~ ğŸ™ƒğŸ¤ªğŸ€

## å‰è¨€  
è¿™ä»½æ–‡æ¡£ä¸»è¦è®°å½•äº†onnxruntimeçš„ä¸€äº›å‚è€ƒèµ„æ–™ï¼Œä»¥åŠæœ¬äººåœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­çš„ä¸€äº›ç»éªŒã€‚

## 1. onnxruntimeå®˜æ–¹èµ„æ–™
* [1] [onnxruntimeå®˜ç½‘å­¦ä¹ èµ„æ–™](https://www.onnxruntime.ai/)
* [2] [onnxruntimeè‡ªå®šä¹‰op](https://www.onnxruntime.ai/docs/how-to/export-pytorch-model.html)
* [3] [onnxruntime-gpuå’Œcudaç‰ˆæœ¬å¯¹åº”](https://github.com/microsoft/onnxruntime/releases/tag/v1.5.1)
* [4] [onnxruntime-openmp](https://pypi.org/project/onnxruntime-openmp/)
* [5] [onnxruntimeå’Œcudaä¹‹é—´çš„ç‰ˆæœ¬å¯¹åº”-å¾ˆè¯¦ç»†](https://www.onnxruntime.ai/docs/reference/execution-providers/CUDA-ExecutionProvider.html#version-dependency)
* [6] [onnxruntime-apiæ–‡æ¡£](https://www.onnxruntime.ai/docs/get-started/inference.html)
* [7] [onnxruntime-python-api-docs](https://www.onnxruntime.ai/python/api_summary.html#)
* [8] [onnxruntime-java-api-docs](https://www.onnxruntime.ai/java/)

## 2.onnxruntime-C++å‚è€ƒ
* [1] [onnx_runtime_cpp-github](https://github.com/xmba15/onnx_runtime_cpp)
* [2] [onnxruntime python/c/c++/javaä½¿ç”¨æ¡ˆåˆ—](https://www.onnxruntime.ai/docs/get-started/inference.html)
* [3] [onnxruntime-å„ç§è¯­è¨€å®˜æ–¹æ¡ˆåˆ—](https://github.com/microsoft/onnxruntime/tree/master/samples)
* [4] [onnxruntimeçš„c++ä½¿ç”¨](https://blog.csdn.net/baidu_34595620/article/details/112176278)
* [5] [onnxruntime-cxxå®˜æ–¹æ¡ˆä¾‹](https://github.com/microsoft/onnxruntime/blob/master/csharp/test/Microsoft.ML.OnnxRuntime.EndToEndTests.Capi/CXX_Api_Sample.cpp)
* [6] [onnxruntime-FAQ](https://github.com/microsoft/onnxruntime/blob/master/docs/FAQ.md)
* [7] [onnxruntime-c++å¤šè¾“å…¥å¤šæ•°å‡ºcase](https://github.com/microsoft/onnxruntime/blob/master/onnxruntime/test/shared_lib/test_inference.cc)

## 3. onnxruntime-javaå‚è€ƒ
* [1] [onnxruntime-minst-java](https://github.com/microsoft/onnxruntime/blob/master/java/src/test/java/sample/ScoreMNIST.java)
* [2] [åœ¨javaä¸­ä½¿ç”¨onnxruntime](https://blog.csdn.net/mzl87/article/details/109170580)
* [3] [onnxruntimeçš„build.gradle](https://github.com/microsoft/onnxruntime/blob/master/java/build.gradle)

## 4. onnxruntimeçš„Dockeré•œåƒ
* [1] [Dockerfile-onnxruntime](https://github.com/microsoft/onnxruntime/tree/master/dockerfiles)

## 5. onnxruntimeæºç ç¼–è¯‘
* [1] [onnxruntimeæºç ç¼–è¯‘](https://blog.csdn.net/wuqingshan2010/article/details/106372580#t1)
* [2] [linuxç¼–è¯‘onnxruntime](https://blog.csdn.net/hxljzx/article/details/111320847?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-1&spm=1001.2101.3001.4242)
* [3] [onnxruntimeç¼–è¯‘é€‰é¡¹è§£æ](https://blog.csdn.net/zhuikefeng/article/details/108672033?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control&dist_request_id=1330144.24052.16181386077064005&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-6.control)
* [4] [onnxtunrimeä¸­CMakeä½¿ç”¨æŒ‡å—å’ŒABI-Dev-Notes](https://blog.csdn.net/xxradon/article/details/104100442/)
* [5] [onnxruntime-cmake_guildline.md](https://github.com/microsoft/onnxruntime/blob/master/docs/cmake_guideline.md)
* [6] [macç¼–è¯‘ä¸­å‡ºç°has no symbolsæç¤º](https://www.cnblogs.com/zzugyl/p/4193647.html)

## 6. å¼€æºé¡¹ç›®
* [1] [chineseocr_lite-onnxruntime/ncnnç­‰å„ç§è¯­è¨€åº”ç”¨](https://github.com/DayBreak-u/chineseocr_lite)
* [2] [onnxruntime-projects](https://codechina.csdn.net/mirrors/tenglike1997/onnxruntime-projects)
* [3] [æ¯”è¾ƒä¸é”™çš„Ort-c++åº”ç”¨é¡¹ç›®](https://github.com/xmba15/onnx_runtime_cpp)


## 7. ä¸ONNXçš„Opsetå…¼å®¹æ€§
* [1] [onnxruntimeä¸onnxå„opsetçš„å¯¹åº”](https://github.com/microsoft/onnxruntime/blob/master/docs/Versioning.md)

![](resources/onnxruntime-opset-version.png)

ä¸å„ä¸ªè½¬æ¢å·¥å…·çš„å…¼å®¹æ€§
![](resources/onnxruntime-toolbox.png)

## 8. è·å–Ort::Valueçš„å€¼
### 8.1 é€šè¿‡At<>è·å–
```c++
TEST(CApiTest, access_tensor_data_elements) {
  /**
   * Create a 2x3 data blob that looks like:
   *
   *  0 1 2
   *  3 4 5
   */
  std::vector<int64_t> shape = {2, 3};
  int element_count = 6;  // 2*3
  std::vector<float> values(element_count);
  for (int i = 0; i < element_count; i++)
    values[i] = static_cast<float>(i);

  Ort::MemoryInfo info("Cpu", OrtDeviceAllocator, 0, OrtMemTypeDefault);

  Ort::Value tensor = Ort::Value::CreateTensor<float>(info, values.data(), values.size(), shape.data(), shape.size());

  float expected_value = 0;
  for (int64_t row = 0; row < shape[0]; row++) {
    for (int64_t col = 0; col < shape[1]; col++) {
      ASSERT_EQ(expected_value++, tensor.At<float>({row, col}));
    }
  }
}
```
### 8.2 é€šè¿‡è£¸æŒ‡é’ˆè·å–
```c++
  const float *var_angles = output_var_tensors.front().GetTensorMutableData<float>();
  const float *conv_angles = output_conv_tensors.front().GetTensorMutableData<float>();
  const float mean_yaw = (var_angles[0] + conv_angles[0]) / 2.0f;
  const float mean_pitch = (var_angles[1] + conv_angles[1]) / 2.0f;
  const float mean_roll = (var_angles[2] + conv_angles[2]) / 2.0f;
```
### 8.3 é€šè¿‡å¼•ç”¨&å’ŒAtè·å–
Ort::Valueä¸å…è®¸å¤åˆ¶æ‹·è´ï¼Œå› æ­¤æ— æ³•é€šè¿‡`=`å»ä½¿ç”¨è¾“å‡ºçš„ç»“æœï¼Œä½†æ˜¯å¯ä»¥ç»“åˆå¼•ç”¨`&+At<>`æ¥è·å–ï¼Œä½¿ç”¨æ–¹å¼å¦‚ä¸‹:
```c++
  ort::Value &var_angles_tensor = output_var_tensors.at(0);
  ort::Value &conv_angles_tensor = output_conv_tensors.at(0);
  const float mean_ref_yaw = 
      (var_angles_tensor.At<float>({0}) + conv_angles_tensor.At<float>({0})) / 2.0f;
  const float mean_ref_pitch = 
      (var_angles_tensor.At<float>({1}) + conv_angles_tensor.At<float>({1})) / 2.0f;
  const float mean_ref_roll =
      (var_angles_tensor.At<float>({2}) + conv_angles_tensor.At<float>({2})) / 2.0f;
```
å¯ä»¥çœ‹åˆ°`At<>`çš„æºç ä¸ºï¼š
```c++
inline T& Value::At(const std::vector<int64_t>& location) {
  static_assert(!std::is_same<T, std::string>::value, "this api does not support std::string");
  T* out;
  ThrowOnError(GetApi().TensorAt(p_, location.data(), location.size(), (void**)&out));
  return *out;
}
```
å®é™…ä¸Šä¹Ÿæ˜¯åˆ©ç”¨æŒ‡é’ˆ`p_`è·å–æ•°æ®ï¼Œåªä¸è¿‡`At`æ›¿æˆ‘ä»¬å¤„ç†äº†æ•°æ®ä½ç½®çš„è®¡ç®—ã€‚è¿™ä¸ªæ–¹æ³•è¿”å›çš„å®é™…ä¸Šæ˜¯ä¸€ä¸ª`éconst`å¼•ç”¨ï¼Œè¿™æ„å‘³ç€ä½ å¯ä»¥é€šè¿‡è¿™ä¸ªå¼•ç”¨ç›´æ¥ä¿®æ”¹å†…å­˜ä¸­çš„å€¼ã€‚
### 8.4 å…¶ä»–ç”¨æ³•å‚è€ƒ
```c++
std::vector<OrtSessionHandler::DataOutputType> OrtSessionHandler::OrtSessionHandlerIml::
operator()(const std::vector<float*>& inputData)
{
    if (m_numInputs != inputData.size()) {
        throw std::runtime_error("Mismatch size of input data\n");
    }

    Ort::MemoryInfo memoryInfo = Ort::MemoryInfo::CreateCpu(OrtArenaAllocator, OrtMemTypeDefault);

    std::vector<Ort::Value> inputTensors;
    inputTensors.reserve(m_numInputs);

    for (int i = 0; i < m_numInputs; ++i) {
        inputTensors.emplace_back(std::move(
            Ort::Value::CreateTensor<float>(memoryInfo, const_cast<float*>(inputData[i]), m_inputTensorSizes[i],
                                            m_inputShapes[i].data(), m_inputShapes[i].size())));
    }

    auto outputTensors = m_session.Run(Ort::RunOptions{nullptr}, m_inputNodeNames.data(), inputTensors.data(),
                                       m_numInputs, m_outputNodeNames.data(), m_numOutputs);

    assert(outputTensors.size() == m_numOutputs);
    std::vector<DataOutputType> outputData;
    outputData.reserve(m_numOutputs);

    int count = 1;
    for (auto& elem : outputTensors) {
        DEBUG_LOG("type of input %d: %s", count++, toString(elem.GetTensorTypeAndShapeInfo().GetElementType()).c_str());
        outputData.emplace_back(
            std::make_pair(std::move(elem.GetTensorMutableData<float>()), elem.GetTensorTypeAndShapeInfo().GetShape()));
    }

    return outputData;
}
```

## 9. æºç åº”ç”¨æ¡ˆä¾‹
* [1] [onnxruntime-c++å¤šè¾“å…¥å¤šè¾“å‡ºæ¡ˆåˆ—](https://blog.csdn.net/baidu_34595620/article/details/112176278)
```c++
#include <assert.h>
#include <vector>
#include <onnxruntime_cxx_api.h>

int main(int argc, char* argv[]) {
  Ort::Env env(ORT_LOGGING_LEVEL_WARNING, "test");
  Ort::SessionOptions session_options;
  session_options.SetIntraOpNumThreads(1);
  session_options.SetGraphOptimizationLevel(GraphOptimizationLevel::ORT_ENABLE_EXTENDED);

#ifdef _WIN32
  const wchar_t* model_path = L"model.onnx";
#else
  const char* model_path = "model.onnx";
#endif

  Ort::Session session(env, model_path, session_options);
  // print model input layer (node names, types, shape etc.)
  Ort::AllocatorWithDefaultOptions allocator;

  // print number of model input nodes
  size_t num_input_nodes = session.GetInputCount();
  std::vector<const char*> input_node_names = {"input","input_mask"};
  std::vector<const char*> output_node_names = {"output","output_mask"};
    
  std::vector<int64_t> input_node_dims = {10, 20};
  size_t input_tensor_size = 10 * 20; 
  std::vector<float> input_tensor_values(input_tensor_size);
  for (unsigned int i = 0; i < input_tensor_size; i++)
    input_tensor_values[i] = (float)i / (input_tensor_size + 1);
  // create input tensor object from data values
  auto memory_info = Ort::MemoryInfo::CreateCpu(OrtArenaAllocator, OrtMemTypeDefault);
  Ort::Value input_tensor = Ort::Value::CreateTensor<float>(memory_info, input_tensor_values.data(), input_tensor_size, input_node_dims.data(), 2);
  assert(input_tensor.IsTensor());

  std::vector<int64_t> input_mask_node_dims = {1, 20, 4};
  size_t input_mask_tensor_size = 1 * 20 * 4; 
  std::vector<float> input_mask_tensor_values(input_mask_tensor_size);
  for (unsigned int i = 0; i < input_mask_tensor_size; i++)
    input_mask_tensor_values[i] = (float)i / (input_mask_tensor_size + 1);
  // create input tensor object from data values
  auto mask_memory_info = Ort::MemoryInfo::CreateCpu(OrtArenaAllocator, OrtMemTypeDefault);
  Ort::Value input_mask_tensor = Ort::Value::CreateTensor<float>(mask_memory_info, input_mask_tensor_values.data(), input_mask_tensor_size, input_mask_node_dims.data(), 3);
  assert(input_mask_tensor.IsTensor());
    
  std::vector<Ort::Value> ort_inputs;
  ort_inputs.push_back(std::move(input_tesor));
  ort_inputs.push_back(std::move(input_mask_tensor));
  // score model & input tensor, get back output tensor
  auto output_tensors = session.Run(Ort::RunOptions{nullptr}, input_node_names.data(), ort_inputs.data(), ort_inputs.size(), output_node_names.data(), 2);
  
  // Get pointer to output tensor float values
  float* floatarr = output_tensors[0].GetTensorMutableData<float>();
  float* floatarr_mask = output_tensors[1].GetTensorMutableData<float>();
  
  printf("Done!\n");
  return 0;
}

```

## 9. onnxruntimeåŠ¨æ€ç»´åº¦æ¨ç†
* [1] [onnxruntime-c++ dynamicç»´åº¦æ¨¡å‹çš„æ¨ç†](https://blog.csdn.net/baidu_34595620/article/details/112176278)

## 10. onnxruntimeæºç å­¦ä¹ 
* [0] [onnxruntimeæºç é˜…è¯»ï¼šæ¨¡å‹æ¨ç†è¿‡ç¨‹æ¦‚è§ˆ](https://blog.csdn.net/ZM_Yang/article/details/103977679?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs)
* [1] [onnxruntimeæºç è§£æï¼šå¼•æ“è¿è¡Œè¿‡ç¨‹æ€»è§ˆ](https://blog.csdn.net/ZM_Yang/article/details/105158051)
* [2] [pytorch-onnx-operator-export-typeè®¾ç½®](https://pytorch.org/docs/stable/onnx.html?highlight=onnx%20runtime#tracing-vs-scripting)
* [3] [onnxruntimeä¸pytorchå¯¹æ¥æ–¹æ³•æ±‡æ€»](https://blog.csdn.net/xxradon/article/details/104182111?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-3.baidujs&dist_request_id=1330144.24096.16181393611009723&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-3.baidujs)
* [4] [onnxruntimeçš„è®¾è®¡ç†å¿µ](https://blog.csdn.net/xxradon/article/details/104099603?spm=1001.2014.3001.5501)
* [5] [onnxruntimeå¢åŠ æ–°çš„operatorå’Œkernel](https://blog.csdn.net/xxradon/article/details/104100114?spm=1001.2014.3001.5501)
* [6] [onnxæ¨¡å‹å¦‚ä½•ä¿®æ”¹æˆ–åˆ é™¤é‡Œé¢çš„nodeå³ä¿®æ”¹å›¾çš„æ–¹æ³•](https://blog.csdn.net/xxradon/article/details/104715524?spm=1001.2014.3001.5501)
* [7] [onnxruntimeæ·»åŠ ä¸€ä¸ªæ–°çš„execution-provider](https://blog.csdn.net/xxradon/article/details/104100243?spm=1001.2014.3001.5501)
* [8] [onnxruntimeå›¾ä¼˜åŒ–æ–¹æ³•è¯´æ˜](https://blog.csdn.net/xxradon/article/details/104117617?spm=1001.2014.3001.5501)
* [9] [onnxç»“æ„åˆ†æ](https://blog.csdn.net/u013597931/article/details/84401047?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.baidujs&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-4.baidujs)

![](https://img.shields.io/github/stars/DefTruth/lite.ai.toolkit.svg?style=social) ![](https://img.shields.io/github/forks/DefTruth/lite.ai.toolkit.svg?style=social) ![](https://img.shields.io/github/watchers/DefTruth/lite.ai.toolkit.svg?style=social)

æ•´ç†ä¸æ˜“ï¼Œæ¬¢è¿å…³æ³¨ï¼ŒğŸŒŸç‚¹èµæ”¶è—~ ğŸ™ƒğŸ¤ªğŸ€
